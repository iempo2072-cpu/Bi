-- YomoHub_v2.lua
-- Cleaned & fixed version: Direct shot + BulletSpeed in Silent Aim tab.
-- Removed Anti-Recoil and combined hooks; added robust checks so the script doesn't error on nils.

local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Camera = workspace.CurrentCamera
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:FindFirstChild("Humanoid")
local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")
local Mouse = LocalPlayer:GetMouse()

local Window = WindUI:CreateWindow({
    Title = "Yomo HUB üßë‚Äçüíª | v2",
    Icon = "menu",
    Author = "https://discord.gg/xWW3jhKM",
    Folder = "KungHubkFolder",
    Size = UDim2.fromOffset(400, 200),
    Theme = "Dark",
    Transparent = true,
    Resizable = true,
})

local button = Window:EditOpenButton({
    Title = "Open Menu",
    Icon = "apple",
    CornerRadius = UDim.new(0,50),
    StrokeThickness = 2,
    Color = ColorSequence.new(Color3.fromHSV(0, 1, 1), Color3.fromHSV(0.1, 1, 1)),
    OnlyMobile = false,
    Enabled = true,
    Draggable = false,
})

local Tab = Window:Tab({Title = "Silent Aim", Icon = "crosshair"})

-- Silent aim config
local SilentAimEnabled = false
local FOVRadius = 120
local CurrentTarget = nil

-- New features
local DirectShotEnabled = false
local BulletSpeed = 4000

-- Variables used by other tabs
local hookEnabled = false -- for melee hook (kept from original)
local CounterTable = {}

-- Drawing UI
local SilentFOVCircle = Drawing.new("Circle")
SilentFOVCircle.Color = Color3.fromRGB(255, 255, 0)
SilentFOVCircle.Thickness = 1
SilentFOVCircle.NumSides = 64
SilentFOVCircle.Filled = false
SilentFOVCircle.Transparency = 1
SilentFOVCircle.Radius = FOVRadius
SilentFOVCircle.Visible = false

local Tracer = Drawing.new("Line")
Tracer.Thickness = 1
Tracer.Color = Color3.fromRGB(0, 255, 255)
Tracer.Transparency = 1
Tracer.Visible = false

-- Helpers
local function safeFindPlayerGuiPing()
    local ok, stats = pcall(function()
        return LocalPlayer:FindFirstChild("PlayerGui") and LocalPlayer.PlayerGui:FindFirstChild("NetworkStats")
    end)
    if ok and stats then
        local pingText = stats:FindFirstChild("PingLabel")
        if pingText and pingText.Text then
            local ping = tonumber(pingText.Text:match("%d+"))
            return ping and ping/1000 or 0.2
        end
    end
    return 0.2
end

local function getPing()
    return safeFindPlayerGuiPing()
end

local function getClosestTarget()
    local closest = nil
    local shortestDistance = math.huge
    local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
            local head = player.Character.Head
            local pos, onScreen = pcall(function() return Camera:WorldToViewportPoint(head.Position) end)
            if pos then
                local viewportPos, isOnScreen = Camera:WorldToViewportPoint(head.Position)
                if isOnScreen then
                    local screenPos = Vector2.new(viewportPos.X, viewportPos.Y)
                    local distFromCenter = (screenPos - center).Magnitude
                    if distFromCenter <= FOVRadius then
                        local toTarget = (head.Position - Camera.CFrame.Position).Unit
                        local forward = Camera.CFrame.LookVector
                        local dot = forward:Dot(toTarget)
                        if dot > 0.5 then
                            local myHead = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head")
                            if myHead then
                                local distance3D = (head.Position - myHead.Position).Magnitude
                                if distance3D < shortestDistance then
                                    shortestDistance = distance3D
                                    closest = player
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    return closest
end

local function predictPosition(head, hrp)
    local ping = getPing()
    local velocity = hrp and hrp.Velocity or Vector3.new()
    return head.Position + (velocity * ping * 1.15)
end

RunService.RenderStepped:Connect(function()
    pcall(function()
        SilentFOVCircle.Visible = SilentAimEnabled
        SilentFOVCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
        SilentFOVCircle.Radius = FOVRadius

        if SilentAimEnabled then
            CurrentTarget = getClosestTarget()
        else
            CurrentTarget = nil
        end

        if CurrentTarget and CurrentTarget.Character and CurrentTarget.Character:FindFirstChild("Head") then
            local targetHead = CurrentTarget.Character.Head
            local myHead = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head")
            local humanoid = CurrentTarget.Character:FindFirstChild("Humanoid")
            if myHead then
                local myScreenPos, myOnScreen = Camera:WorldToViewportPoint(myHead.Position)
                local targetScreenPos, targetOnScreen = Camera:WorldToViewportPoint(targetHead.Position)
                if myOnScreen and targetOnScreen then
                    Tracer.Visible = true
                    Tracer.From = Vector2.new(myScreenPos.X, myScreenPos.Y)
                    Tracer.To = Vector2.new(targetScreenPos.X, targetScreenPos.Y)
                    if humanoid then
                        local perc = humanoid.Health / humanoid.MaxHealth
                        Tracer.Color = Color3.fromHSV(perc * 0.333, 1, 1)
                    end
                else
                    Tracer.Visible = false
                end
            end
        else
            Tracer.Visible = false
        end
    end)
end)

local function isBehindWall(startPos, endPos)
    if not startPos or not endPos then return false end
    local ok, hit = pcall(function()
        local ray = Ray.new(startPos, endPos - startPos)
        local ignoreList = {LocalPlayer.Character, CurrentTarget and CurrentTarget.Character or nil}
        return workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
    end)
    return ok and hit ~= nil
end

-- Find remotes robustly
local remotesFolder = ReplicatedStorage:FindFirstChild("Remotes")
if not remotesFolder then
    -- try WaitForChild as fallback (may yield)
    remotesFolder = ReplicatedStorage:WaitForChild("Remotes", 5)
end
local Remote = nil
if remotesFolder then
    Remote = remotesFolder:FindFirstChild("Send") or remotesFolder:WaitForChild("Send", 5)
end
if not Remote then
    warn("Remote 'Send' not found in ReplicatedStorage.Remotes. Silent Aim will not function.")
end

-- Single unified hook for Remote.FireServer (handles shoot_gun and melee_attack)
local oldFire
if Remote and Remote.FireServer then
    oldFire = hookfunction(Remote.FireServer, function(self, ...)
        if self ~= Remote then
            return oldFire(self, ...)
        end

        local args = {...}
        -- SHOOT_GUN handling (Silent Aim)
        if SilentAimEnabled and args[2] == "shoot_gun" and CurrentTarget then
            pcall(function()
                local head = CurrentTarget.Character and CurrentTarget.Character:FindFirstChild("Head")
                local hrp = CurrentTarget.Character and CurrentTarget.Character:FindFirstChild("HumanoidRootPart")
                local humanoid = CurrentTarget.Character and CurrentTarget.Character:FindFirstChild("Humanoid")
                if head and humanoid and hrp then
                    local aimPos = predictPosition(head, hrp)
                    local displacement = aimPos - head.Position
                    local hitCFrame = CurrentTarget.Character:GetPivot() + displacement
                    local previousHealth = humanoid.Health

                    local isObstructed = isBehindWall((LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head") and LocalPlayer.Character.Head.Position) or Vector3.new(), aimPos)

                    if DirectShotEnabled then
                        if type(args[5]) == "table" and args[5][1] and args[5][1][1] then
                            args[5][1][1]["Position"] = aimPos
                        else
                            args[5] = {
                                [1] = {
                                    [1] = {
                                        ["Instance"] = head,
                                        ["Normal"] = Vector3.new(0, 1, 0),
                                        ["Position"] = aimPos
                                    }
                                }
                            }
                        end
                        args[4] = CFrame.new(aimPos)
                    else
                        args[4] = CFrame.new(math.huge, math.huge, math.huge)
                    end

                    -- Set bullet speed
                    args[6] = BulletSpeed

                    -- Visual beam
                    local headPos = (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head") and LocalPlayer.Character.Head.Position) or Vector3.new()
                    local beam = Instance.new("Part")
                    beam.Anchored = true
                    beam.CanCollide = false
                    beam.Size = Vector3.new(0.15, 0.15, (aimPos - headPos).Magnitude)
                    if beam.Size.Z == 0 then beam.Size = Vector3.new(0.15,0.15,1) end
                    beam.CFrame = CFrame.new(headPos, aimPos) * CFrame.new(0, 0, -beam.Size.Z/2)
                    beam.Material = Enum.Material.Neon
                    beam.Transparency = 0.25
                    beam.Parent = workspace
                    Debris:AddItem(beam, 4)

                    spawn(function()
                        wait(0.1)
                        if humanoid and humanoid.Health < previousHealth then
                            beam.Color = Color3.fromRGB(0, 255, 0)
                            -- Hit ghost effect (same as original)
                            local targetCharacter = CurrentTarget.Character
                            local clone = targetCharacter:Clone()
                            clone.Name = "HitGhost"
                            clone.PrimaryPart = clone:FindFirstChild("HumanoidRootPart")
                            for _, child in ipairs(clone:GetChildren()) do
                                if child:IsA("Humanoid") or child:IsA("Script") or child:IsA("LocalScript") then
                                    child:Destroy()
                                end
                            end
                            for _, descendant in ipairs(clone:GetDescendants()) do
                                if descendant:IsA("BasePart") then
                                    descendant.Anchored = true
                                    descendant.CanCollide = false
                                    descendant.Material = Enum.Material.Neon
                                    descendant.Color = Color3.fromRGB(128, 0, 128)
                                    descendant.Transparency = 0.5
                                elseif descendant:IsA("Decal") or descendant:IsA("Texture") then
                                    descendant:Destroy()
                                end
                            end
                            local highlight = Instance.new("Highlight")
                            highlight.OutlineColor = Color3.fromRGB(128, 0, 128)
                            highlight.FillColor = Color3.fromRGB(128, 0, 128)
                            highlight.OutlineTransparency = 0
                            highlight.FillTransparency = 0.7
                            highlight.Parent = clone
                            clone:SetPivot(hitCFrame)
                            clone.Parent = workspace
                            local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Linear)
                            local partGoals = {Transparency = 1}
                            local highlightGoals = {OutlineTransparency = 1, FillTransparency = 1}
                            for _, descendant in ipairs(clone:GetDescendants()) do
                                if descendant:IsA("BasePart") then
                                    TweenService:Create(descendant, tweenInfo, partGoals):Play()
                                end
                            end
                            TweenService:Create(highlight, tweenInfo, highlightGoals):Play()
                            Debris:AddItem(clone, 2)
                        else
                            beam.Color = Color3.fromRGB(255, 0, 0)
                        end
                    end)
                end
            end)
            -- Call original remote with modified args
            return oldFire(self, unpack(args))
        end

        -- MELEE handling (kept from original behavior)
        if hookEnabled and args[2] == "melee_attack" and args[3] then
            pcall(function()
                local targetPlayer = nil
                local localPos = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart and LocalPlayer.Character.PrimaryPart.Position
                if localPos then
                    local nearestDistance = 15
                    for _, player in pairs(Players:GetPlayers()) do
                        if player ~= LocalPlayer and player.Character and player.Character.PrimaryPart then
                            local distance = (player.Character.PrimaryPart.Position - localPos).Magnitude
                            if distance <= nearestDistance then
                                nearestDistance = distance
                                targetPlayer = player
                            end
                        end
                    end
                end
                if targetPlayer then
                    args[4] = {targetPlayer}
                    local enemyPos = targetPlayer.Character.PrimaryPart.Position
                    local localPos = LocalPlayer.Character.PrimaryPart.Position
                    local lookAtCFrame = CFrame.lookAt(localPos, enemyPos)
                    args[5] = lookAtCFrame
                end
            end)
            return oldFire(self, unpack(args))
        end

        return oldFire(self, unpack(args))
    end)
else
    warn("Remote 'Send' not found or it has no FireServer method. Hook not applied.")
end

-- UI Controls for Silent Aim (Direct Shot + Bullet Speed)
Tab:Toggle({
    Title = "Silent Aim",
    Default = false,
    Callback = function(state)
        SilentAimEnabled = state
    end
})

Tab:Toggle({
    Title = "Direct Shot",
    Default = false,
    Callback = function(state)
        DirectShotEnabled = state
        if state then
            WindUI:Notify({Title="Direct Shot Enabled", Description="‡∏¢‡∏¥‡∏á‡∏ï‡∏£‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß", Duration=2})
        else
            WindUI:Notify({Title="Direct Shot Disabled", Description="‡∏¢‡∏¥‡∏á‡∏ï‡∏£‡∏á‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß", Duration=2})
        end
    end
})

Tab:Slider({
    Title = "Bullet Speed",
    Step = 1,
    Value = {
        Min = 100,
        Max = 10000,
        Default = BulletSpeed,
    },
    Callback = function(value)
        BulletSpeed = tonumber(value) or 4000
        print("BulletSpeed", BulletSpeed)
    end
})

Tab:Slider({
    Title = "FOV: ",
    Step = 1,
    Value = {
        Min = 20,
        Max = 500,
        Default = FOVRadius,
    },
    Callback = function(value)
        FOVRadius = tonumber(value) or 120
        print("FOV",FOVRadius)
    end
})

-- (ESP, Character and other tabs are unchanged and kept from original; omitted here for brevity)
-- If you want the rest included again, tell me and I'll append them back verbatim.
