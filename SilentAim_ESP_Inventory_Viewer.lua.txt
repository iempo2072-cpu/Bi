-- ‡πÇ‡∏´‡∏•‡∏î WindUI
local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Camera = workspace.CurrentCamera
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
local Mouse = LocalPlayer:GetMouse()

local Window = WindUI:CreateWindow({
    Title = "god hubüåç | v0.1a  | ",
    Icon = "menu",
    Author = "ü¶Ö",
    Folder = "yomoHubkFolder",
    Size = UDim2.fromOffset(400, 200),
    Theme = "Dark",
    Transparent = true,
    Resizable = true,
})

local button = Window:EditOpenButton({
    Title = " Menu ¬©",
    Icon = "apple",
    CornerRadius = UDim.new(0,50),
    StrokeThickness = 2,
    Color = ColorSequence.new(Color3.fromHSV(0, 1, 1), Color3.fromHSV(0.1, 1, 1)),
    OnlyMobile = false,
    Enabled = true,
    Draggable = false,
})

---------------------------------
-- Silent Aim Tab & Logic -----
---------------------------------
local Tab = Window:Tab({Title = "Silent Aim", Icon = "crosshair"})
local SilentAimEnabled = false
local NoRecoilEnabled = true
local FOVRadius = 120
local CurrentTarget = nil

local ConstantPingTime = 0.2 -- ‡∏î‡∏±‡∏Å‡∏õ‡∏¥‡∏á‡πÄ‡∏õ‡πá‡∏ô 200ms
local ConstantBulletSpeed = 2000

local SilentFOVCircle = Drawing.new("Circle")
SilentFOVCircle.Color = Color3.fromRGB(255, 255, 0)
SilentFOVCircle.Thickness = 1
SilentFOVCircle.NumSides = 64
SilentFOVCircle.Filled = false
SilentFOVCircle.Transparency = 1
SilentFOVCircle.Radius = FOVRadius
SilentFOVCircle.Visible = false

local Tracer = Drawing.new("Line")
Tracer.Thickness = 1
Tracer.Color = Color3.fromRGB(0, 255, 255)
Tracer.Transparency = 1
Tracer.Visible = false

-- Raycast ‡πÄ‡∏ä‡πá‡∏Å‡∏Å‡∏≥‡πÅ‡∏û‡∏á
local function isBehindWall(startPos, endPos)
    if (startPos - endPos).Magnitude < 2 then return false end
    local ignore = {LocalPlayer.Character}
    if CurrentTarget and CurrentTarget.Character then
        table.insert(ignore, CurrentTarget.Character)
    end
    local params = RaycastParams.new()
    params.FilterDescendantsInstances = ignore
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.IgnoreWater = true
    local direction = (endPos - startPos).Unit
    local distance = (endPos - startPos).Magnitude
    local rayResult = workspace:Raycast(startPos, direction * distance, params)
    if rayResult and rayResult.Instance then
        if not (rayResult.Instance:IsDescendantOf(CurrentTarget.Character) or rayResult.Instance:IsDescendantOf(LocalPlayer.Character)) then
            return true
        end
    end
    return false
end

-- ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£ predict ‡πÅ‡∏ö‡∏ö‡∏î‡∏±‡∏Å ping 200ms
local function predictWallbangPosition_New(head, hrp)
    -- ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏¢‡∏¥‡∏á‡∏•‡πà‡∏ß‡∏á‡∏´‡∏ô‡πâ‡∏≤‡πÅ‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà
    local velocity = hrp and hrp.Velocity or Vector3.zero
    local origin = Camera.CFrame.Position
    local toTarget = head.Position - origin
    local distance = toTarget.Magnitude

    -- ‡∏Å‡∏£‡∏∞‡∏™‡∏∏‡∏ô‡πÅ‡∏•‡∏∞ ping ‡πÅ‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà
    local bulletTime = distance / ConstantBulletSpeed
    local predictTime = bulletTime + ConstantPingTime

    -- ‡∏¢‡∏¥‡∏á‡∏•‡πà‡∏ß‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡∏≤‡∏° vector ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏≠‡∏á‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢
    return head.Position + (velocity * predictTime)
end

local function getClosestTarget()
    local closest = nil
    local shortestDistance = math.huge
    local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
            local head = player.Character.Head
            local pos, onScreen = Camera:WorldToViewportPoint(head.Position)
            if onScreen then
                local screenPos = Vector2.new(pos.X, pos.Y)
                local distFromCenter = (screenPos - center).Magnitude
                if distFromCenter <= FOVRadius then
                    local toTarget = (head.Position - Camera.CFrame.Position).Unit
                    local forward = Camera.CFrame.LookVector
                    local dot = forward:Dot(toTarget)
                    if dot > 0.5 then
                        local distance3D = (head.Position - LocalPlayer.Character.Head.Position).Magnitude
                        if distance3D < shortestDistance then
                            shortestDistance = distance3D
                            closest = player
                        end
                    end
                end
            end
        end
    end

    return closest
end

RunService.RenderStepped:Connect(function()
    SilentFOVCircle.Visible = SilentAimEnabled
    SilentFOVCircle.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    SilentFOVCircle.Radius = FOVRadius

    if SilentAimEnabled then
        CurrentTarget = getClosestTarget()
    else
        CurrentTarget = nil
    end

    if CurrentTarget and CurrentTarget.Character and CurrentTarget.Character:FindFirstChild("Head") then
        local targetHead = CurrentTarget.Character.Head
        local myHead = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head")
        local humanoid = CurrentTarget.Character:FindFirstChild("Humanoid")
        if myHead then
            local myScreenPos, myOnScreen = Camera:WorldToViewportPoint(myHead.Position)
            local targetScreenPos, targetOnScreen = Camera:WorldToViewportPoint(targetHead.Position)
            if myOnScreen and targetOnScreen then
                Tracer.Visible = true
                Tracer.From = Vector2.new(myScreenPos.X, myScreenPos.Y)
                Tracer.To = Vector2.new(targetScreenPos.X, targetScreenPos.Y)
                if humanoid then
                    local perc = humanoid.Health / humanoid.MaxHealth
                    Tracer.Color = Color3.fromHSV(perc * 0.333, 1, 1)
                end
            else
                Tracer.Visible = false
            end
        end
    else
        Tracer.Visible = false
    end
end)

local function doRecoilGunMods()
    while true do
        task.wait(1)
        -- No Recoil Gun Mods Logic (compatible with normal tools & Attribute)
        for _, tool in pairs(LocalPlayer.Backpack:GetChildren()) do
            if tool:IsA("Tool") and (tool:FindFirstChild("Recoil") or tool:GetAttribute("Recoil")) then
                if tool:FindFirstChild("Recoil") then tool.Recoil.Value = 0 end
                if tool:GetAttribute("Recoil") then tool:SetAttribute("Recoil", 0) end
            end
        end
        for _, tool in pairs(LocalPlayer.Character:GetChildren()) do
            if tool:IsA("Tool") and (tool:FindFirstChild("Recoil") or tool:GetAttribute("Recoil")) then
                if tool:FindFirstChild("Recoil") then tool.Recoil.Value = 0 end
                if tool:GetAttribute("Recoil") then tool:SetAttribute("Recoil", 0) end
            end
        end
    end
end
spawn(doRecoilGunMods)

local Remote = ReplicatedStorage.Remotes.Send
local oldFire
oldFire = hookfunction(Remote.FireServer, function(self, ...)
    if self ~= Remote then
        return oldFire(self, ...)
    end
    local args = {...}
    if SilentAimEnabled and args[2] == "shoot_gun" and CurrentTarget then
        local head = CurrentTarget.Character and CurrentTarget.Character:FindFirstChild("Head")
        local hrp = CurrentTarget.Character and CurrentTarget.Character:FindFirstChild("HumanoidRootPart")
        local humanoid = CurrentTarget.Character:FindFirstChild("Humanoid")
        if head and humanoid and hrp then
            local myHeadPos = LocalPlayer.Character.Head.Position
            local targetPos = head.Position

            local wallbang = isBehindWall(myHeadPos, targetPos)
            local aimPos
            if wallbang then
                -- ‡πÉ‡∏ä‡πâ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏¢‡∏¥‡∏á‡∏ó‡∏∞‡∏•‡∏∏
                aimPos = predictWallbangPosition_New(head, hrp)
            else
                -- ‡∏¢‡∏¥‡∏á‡∏õ‡∏Å‡∏ï‡∏¥‡∏ó‡∏µ‡πà‡∏´‡∏±‡∏ß
                aimPos = targetPos
            end

            args[4] = CFrame.new(math.huge, math.huge, math.huge)
            args[5] = {
                [1] = {
                    [1] = {
                        ["Instance"] = head,
                        ["Normal"] = Vector3.new(0, 1, 0),
                        ["Position"] = aimPos,
                        ["Wallbang"] = wallbang
                    }
                }
            }

            -- Beam effect
            local beam = Instance.new("Part")
            beam.Anchored = true
            beam.CanCollide = false
            beam.Size = Vector3.new(0.15, 0.15, (aimPos - LocalPlayer.Character.Head.Position).Magnitude)
            beam.CFrame = CFrame.new(LocalPlayer.Character.Head.Position, aimPos) * CFrame.new(0, 0, -beam.Size.Z/2)
            beam.Material = Enum.Material.Neon
            beam.Transparency = 0.25
            beam.Parent = workspace
            Debris:AddItem(beam, 4)

            spawn(function()
                wait(0.1)
                if humanoid and humanoid.Health < humanoid.MaxHealth then
                    beam.Color = wallbang and Color3.fromRGB(0, 128, 255) or Color3.fromRGB(0, 255, 0)
                else
                    beam.Color = Color3.fromRGB(255, 0, 0)
                end
            end)
        end
    end
    return oldFire(self, unpack(args))
end)

Tab:Toggle({
    Title = "Silent Aim",
    Default = false,
    Callback = function(state)
        SilentAimEnabled = state
    end
})

Tab:Toggle({
    Title = "No Recoil (‡∏Å‡∏±‡∏ô‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏î‡∏µ‡∏î)",
    Default = true,
    Callback = function(state)
        NoRecoilEnabled = state
    end
})

Tab:Slider({
    Title = "FOV: ",
    Step = 1,
    Value = {
        Min = 20,
        Max = 500,
        Default = FOVRadius,
    },
    Callback = function(value)
        FOVRadius = tonumber(value) or 120
    end
})

-------------------------------
-- ESP Tab & Logic ------------
-------------------------------

local Tab_ESP = Window:Tab({
    Title = "ESP",
    Icon = "eye",
})

local boxESPEnabled = false
local nameESPEnabled = false
local itemESPEnabled = false -- used for Inventory Viewer (player inventory)
local itemDropESPEnabled = false -- NEW: Item Drop ESP (‡∏Ç‡∏≠‡∏á‡∏ï‡∏Å‡∏û‡∏∑‡πâ‡∏ô)
local espPlayers = {}

Tab_ESP:Toggle({
    Title = "Box ESP",
    Default = false,
    Callback = function(state)
        boxESPEnabled = state
    end
})

Tab_ESP:Toggle({
    Title = "Name ESP",
    Default = false,
    Callback = function(state)
        nameESPEnabled = state
    end
})

Tab_ESP:Toggle({
    Title = "Inventory Viewer ESP",
    Default = false,
    Callback = function(state)
        itemESPEnabled = state
    end
})

Tab_ESP:Toggle({
    Title = "Item Drop ESP", -- ‡∏õ‡∏∏‡πà‡∏°‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏°‡∏≠‡∏á‡∏Ç‡∏≠‡∏á‡∏ï‡∏Å‡∏û‡∏∑‡πâ‡∏ô
    Default = false,
    Callback = function(state)
        itemDropESPEnabled = state
    end
})

local function getPlayerInventory(player)
    local inv = {}
    local backpack = player:FindFirstChildOfClass("Backpack")
    if backpack then
        for _, item in pairs(backpack:GetChildren()) do
            if item.Name and item:IsA("Tool") then
                table.insert(inv, item.Name)
            end
        end
    end
    -- Check for equipped Item (‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠/‡∏ñ‡∏∑‡∏≠‡∏≠‡∏¢‡∏π‡πà)
    if player.Character then
        for _, obj in pairs(player.Character:GetChildren()) do
            if obj:IsA("Tool") then
                table.insert(inv, "[E] " .. obj.Name)
            end
        end
    end
    return inv
end

local function createESP(player)
    local lines = {
        top = Drawing.new("Line"),
        bottom = Drawing.new("Line"),
        left = Drawing.new("Line"),
        right = Drawing.new("Line"),
    }
    local nameText = Drawing.new("Text")
    nameText.Size = 16
    nameText.Center = true
    nameText.Outline = true
    nameText.Color = Color3.fromRGB(255, 0, 0)

    local itemText = Drawing.new("Text")
    itemText.Size = 15
    itemText.Center = true
    itemText.Outline = true
    itemText.Color = Color3.fromRGB(0, 255, 128)

    for _, line in pairs(lines) do
        line.Color = Color3.new(1, 1, 1)
        line.Thickness = 1
        line.Visible = false
    end
    nameText.Visible = false
    itemText.Visible = false

    local drawings = {lines.top, lines.bottom, lines.left, lines.right, nameText, itemText}

    local conn = RunService.RenderStepped:Connect(function()
        if not player.Character or not player.Character:FindFirstChild("Head") or not player.Character:FindFirstChild("HumanoidRootPart") then
            for _, line in pairs(lines) do line.Visible = false end
            nameText.Visible = false
            itemText.Visible = false
            return
        end

        local head = player.Character.Head
        local hrp = player.Character.HumanoidRootPart

        local topWorld = head.Position + Vector3.new(0, 1, 0)
        local bottomWorld = hrp.Position - Vector3.new(0, 3.5, 0)

        local top, onTop = Camera:WorldToViewportPoint(topWorld)
        local bottom, onBottom = Camera:WorldToViewportPoint(bottomWorld)

        if onTop and onBottom and top.Z > 0 and bottom.Z > 0 then
            local height = math.abs(top.Y - bottom.Y) * 1.2
            local width = height / 1.5
            local x = top.X - width / 2
            local y = top.Y - height * 0.1

            local tl = Vector2.new(x, y)
            local tr = Vector2.new(x + width, y)
            local bl = Vector2.new(x, y + height)
            local br = Vector2.new(x + width, y + height)

            if boxESPEnabled then
                lines.top.From = tl
                lines.top.To = tr
                lines.bottom.From = bl
                lines.bottom.To = br
                lines.left.From = tl
                lines.left.To = bl
                lines.right.From = tr
                lines.right.To = br
                for _, line in pairs(lines) do line.Visible = true end
            else
                for _, line in pairs(lines) do line.Visible = false end
            end

            if nameESPEnabled then
                nameText.Text = player.Name
                nameText.Position = Vector2.new(top.X, y - 16)
                nameText.Visible = true
            else
                nameText.Visible = false
            end

            if itemESPEnabled then
                local items = getPlayerInventory(player)
                itemText.Text = #items > 0 and "‡∏Ç‡∏≠‡∏á: " .. table.concat(items, ", ") or ""
                itemText.Position = Vector2.new(top.X, y + height + 15)
                itemText.Visible = #items > 0
            else
                itemText.Visible = false
            end
        else
            for _, line in pairs(lines) do line.Visible = false end
            nameText.Visible = false
            itemText.Visible = false
        end
    end)

    espPlayers[player] = {conn = conn, drawings = drawings}
end

local function loadESP()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            createESP(player)
        end
    end

    Players.PlayerAdded:Connect(function(player)
        if player ~= LocalPlayer then
            player.CharacterAdded:Connect(function()
                wait(0.1)
                createESP(player)
            end)
        end
    end)

    Players.PlayerRemoving:Connect(function(player)
        if espPlayers[player] then
            espPlayers[player].conn:Disconnect()
            for _, drawing in pairs(espPlayers[player].drawings) do
                drawing:Remove()
            end
            espPlayers[player] = nil
        end
    end)
end

loadESP()

-------------------------
-- ITEM DROP ESP (‡∏à‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå message.txt ‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏ä‡πâ‡∏Å‡∏±‡∏ö WindUI)
-------------------------

local dropfolder = workspace:FindFirstChild("DroppedItems")
local item_drawings = {}

local function Get2DPos(part)
    local success, pos, onScreen = pcall(function()
        return Camera:WorldToViewportPoint(part.Position)
    end)
    if success then
        return Vector2.new(pos.X, pos.Y), pos.Z, onScreen
    end
    return Vector2.new(0,0), 0, false
end

RunService.RenderStepped:Connect(function()
    if not itemDropESPEnabled then
        for _, d in pairs(item_drawings) do
            if d.box then d.box.Visible = false end
            if d.name then d.name.Visible = false end
            if d.dist then d.dist.Visible = false end
        end
        return
    end

    if not dropfolder then return end

    -- ‡∏•‡∏ö drawings ‡∏Ç‡∏≠‡∏á‡πÑ‡∏≠‡πÄ‡∏ó‡∏°‡∏ó‡∏µ‡πà‡∏´‡∏≤‡∏¢‡πÑ‡∏õ
    for obj, d in pairs(item_drawings) do
        if not obj or not obj.Parent then
            if d.box then d.box:Remove() end
            if d.name then d.name:Remove() end
            if d.dist then d.dist:Remove() end
            item_drawings[obj] = nil
        end
    end

    for _, item in pairs(dropfolder:GetChildren()) do
        if item:IsA("Model") and item:FindFirstChild("PickUpZone") and not item:GetAttribute('Locked') then
            local esp = item_drawings[item]
            if not esp then
                esp = {
                    box = Drawing.new("Square"),
                    name = Drawing.new("Text"),
                    dist = Drawing.new("Text")
                }
                esp.box.Color = Color3.fromRGB(255,255,255)
                esp.box.Thickness = 1
                esp.box.Filled = false

                esp.name.Color = Color3.fromRGB(255,255,255)
                esp.name.Size = 15
                esp.name.Center = true
                esp.name.Outline = true

                esp.dist.Color = Color3.fromRGB(0,255,128)
                esp.dist.Size = 15
                esp.dist.Center = true
                esp.dist.Outline = true

                item_drawings[item] = esp
            end

            local pos, depth, on = Get2DPos(item.PickUpZone)
            if on and depth > 0 then
                local sizescale = math.clamp(100 / depth, 20, 40)
                esp.box.Size = Vector2.new(sizescale, sizescale)
                esp.box.Position = Vector2.new(pos.X - sizescale/2, pos.Y - sizescale/2)
                esp.box.Visible = true

                esp.name.Text = item.Name
                esp.name.Position = Vector2.new(pos.X, pos.Y - sizescale/2 - 10)
                esp.name.Visible = true

                local AmountItem = item:FindFirstChild("AmountBillboardGui") and item.AmountBillboardGui:FindFirstChild("TextLabel")
                esp.dist.Text = "["..(AmountItem and AmountItem.Text or "?").."]"
                esp.dist.Position = Vector2.new(pos.X, pos.Y + sizescale/2 + 5)
                esp.dist.Visible = true
            else
                esp.box.Visible = false
                esp.name.Visible = false
                esp.dist.Visible = false
            end
        end
    end
end)
