-- WindUI config/boot --
local WindUI
do
    local ok, result = pcall(function()
        return require("./src/Init")
    end)
    if ok then
        WindUI = result
    else
        WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/refs/heads/main/dist/main.lua"))()
    end
end

local Window = WindUI:CreateWindow({
    Title = "mo hub",
    Author = "mo hub",
    Folder = "ftgshub",
    Icon = "computer",
    NewElements = true,
    HideSearchBar = false,
    OpenButton = {
        Title = "mo hub",
        CornerRadius = UDim.new(1,0),
        StrokeThickness = 3,
        Enabled = true,
        Draggable = true,
        OnlyMobile = false,
        Color = ColorSequence.new(Color3.fromHex("#30FF6A"), Color3.fromHex("#e7ff2f"))
    }
})

local CombatTab = Window:Tab({Title = "Combat", Icon = "sword"})
local ESPTab = Window:Tab({Title = "ESP", Icon = "eye"})
local AntiAimTab = Window:Tab({Title = "AntiAim", Icon = "arrow-left-right"})

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-------------------------------------------------
-- AntiAim TAB & ‡πÇ‡∏Ñ‡πâ‡∏î (Toggle ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î)
-------------------------------------------------
local aaEnabled = false
local aaRadius = 14
local aaSpeed = 0.085
local velocityPower = 5000
local hrp
local aaConn

AntiAimTab:Toggle({
    Title = "AntiAim",
    Default = false,
    Callback = function(state)
        aaEnabled = state
        if state then
            WindUI:Notify({Title = "‚úÖ AntiAim ‡πÄ‡∏õ‡∏¥‡∏î!", Description = "‡∏Ñ‡∏∏‡∏ì‡∏™‡πà‡∏≤‡∏¢ HRP+‡∏™‡∏∏‡πà‡∏° Velocity", Duration = 2.5})
            if aaConn then aaConn:Disconnect() end
            aaConn = RunService.RenderStepped:Connect(function()
                hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                if not hrp then return end
                -- ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ï‡∏≠‡∏ô AntiAim ‡πÄ‡∏õ‡∏¥‡∏î‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô!
                if aaEnabled then
                    local tickTime = tick()
                    local offsetX = math.cos(tickTime * 85) * aaRadius
                    local offsetZ = math.sin(tickTime * 120) * aaRadius
                    local centerY = hrp.Position.Y
                    hrp.CFrame = CFrame.new(hrp.Position.X + offsetX, centerY, hrp.Position.Z + offsetZ)
                    hrp.Velocity = Vector3.new(math.random(-velocityPower, velocityPower), math.random(-20,20), math.random(-velocityPower, velocityPower))
                end
            end)
        else
            WindUI:Notify({Title = "üîª AntiAim ‡∏õ‡∏¥‡∏î", Description = "‡πÇ‡∏´‡∏°‡∏î‡∏Å‡∏•‡∏±‡∏ö‡∏õ‡∏Å‡∏ï‡∏¥", Duration = 2})
            if aaConn then aaConn:Disconnect() aaConn = nil end
            hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if hrp then hrp.Velocity = Vector3.new(0,0,0) end
        end
    end
})

AntiAimTab:Button({
    Title = "‡πÅ‡∏à‡πâ‡∏á‡∏ß‡πà‡∏≤‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏´‡∏° AntiAim",
    Callback = function()
        if aaEnabled then
            WindUI:Notify({Title = "AntiAim: ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô!", Description = "HRP ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡πà‡∏≤‡∏¢‡∏™‡∏∏‡∏î/‡∏´‡∏•‡∏≠‡∏Å Velocity", Duration = 2})
        else
            WindUI:Notify({Title = "AntiAim: ‡∏õ‡∏¥‡∏î‡∏≠‡∏¢‡∏π‡πà!", Description = "‡∏Å‡∏î‡πÄ‡∏õ‡∏¥‡∏î AntiAim Tab ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°", Duration = 2})
        end
    end
})

-- HookMetamethod: UI/ESP ‡∏Ç‡∏≠‡∏á‡πÄ‡∏£‡∏≤‡∏¢‡∏±‡∏á‡πÄ‡∏´‡πá‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏õ‡∏Å‡∏ï‡∏¥
local mt = getrawmetatable(game)
setreadonly(mt, false)
local old_index = mt.__index
mt.__index = function(obj, key)
    if aaEnabled and obj == hrp and key == "Position" and Players:GetPlayerFromCharacter(obj.Parent) == LocalPlayer then
        local pos = hrp.Position
        return Vector3.new(math.floor(pos.X / aaRadius) * aaRadius, pos.Y, math.floor(pos.Z / aaRadius) * aaRadius)
    end
    return old_index(obj, key)
end
setreadonly(mt, true)


-------------------------------------------------
-- Silent Aim System (Per-player full system)
-- ‡πÄ‡∏≠‡∏≤ ShootDirect ‡∏≠‡∏≠‡∏Å ‡πÅ‡∏•‡∏∞‡∏£‡∏ß‡∏°‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô
-------------------------------------------------
local SilentAimEnabled = false
local BASE_PREDICTION = 0.14
local FOVCircle = Drawing.new("Circle")
FOVCircle.Radius = 120
FOVCircle.Thickness = 2
FOVCircle.Filled = false
FOVCircle.Color = Color3.fromRGB(255,255,0)
FOVCircle.Visible = false
local showFov = false

local TracerLine = Drawing.new("Line")
TracerLine.Color = Color3.fromRGB(0,255,255)
TracerLine.Thickness = 2
TracerLine.Visible = false
local showTracer = true
local tracerColor = Color3.fromRGB(255,120,120)

-- AimSystem: per-player tracking and utilities
local AimSystem = {
    players = {}, -- [userId] = {lastPos = Vector3, lastTime = number, velBuf = {}, bufSize = 7}
    antiaimThreshold = 3.5,
    bufSize = 7,
    basePrediction = BASE_PREDICTION
}

function AimSystem:Ensure(p)
    if not p then return end
    local id = p.UserId
    if not self.players[id] then
        self.players[id] = {
            lastHeadPos = nil,
            lastTime = nil,
            velBuf = {}
        }
    end
    return self.players[id]
end

function AimSystem:UpdatePlayerVelocity(p)
    if not (p and p.Character and p.Character:FindFirstChild("Head")) then return Vector3.new(0,0,0) end
    local data = self:Ensure(p)
    local head = p.Character.Head
    local now = tick()
    if data.lastHeadPos == nil or data.lastTime == nil or data.lastHeadPos == Vector3.new(0,0,0) then
        data.lastHeadPos = head.Position
        data.lastTime = now
        data.velBuf = {}
        return Vector3.new(0,0,0)
    end
    local dt = now - data.lastTime
    data.lastTime = now
    if dt <= 0 then return Vector3.new(0,0,0) end
    local vel = (head.Position - data.lastHeadPos) / dt
    data.lastHeadPos = head.Position
    table.insert(data.velBuf, vel.Magnitude)
    if #data.velBuf > self.bufSize then table.remove(data.velBuf, 1) end
    return vel
end

function AimSystem:IsAntiAiming(p)
    if not (p and p.UserId) then return false end
    local data = self.players[p.UserId]
    if not data or #data.velBuf < 3 then return false end
    local sum = 0
    for _,v in ipairs(data.velBuf) do sum = sum + v end
    local avg = sum / #data.velBuf
    return avg > self.antiaimThreshold
end

function AimSystem:GetPredictedPositionForHead(p, predictionTime)
    predictionTime = predictionTime or self.basePrediction
    if not (p and p.Character and p.Character:FindFirstChild("Head")) then return nil end
    local head = p.Character.Head
    local vel = self:UpdatePlayerVelocity(p)
    return head.Position + vel * predictionTime, head
end

function AimSystem:GetPredictedPositionForHRP(p, predictionTime)
    predictionTime = predictionTime or self.basePrediction
    if not (p and p.Character and p.Character:FindFirstChild("HumanoidRootPart")) then return nil end
    local hrp = p.Character.HumanoidRootPart
    return hrp.Position + hrp.Velocity * predictionTime, hrp
end

function AimSystem:GetBestTargetInFOV()
    local closest, shortest = nil, math.huge
    local myHead = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head")
    if not myHead then return nil end
    for _,plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("Head") then
            local head = plr.Character.Head
            local screenPos, onScreen = Camera:WorldToViewportPoint(head.Position)
            local distFov = (Vector2.new(screenPos.X,screenPos.Y) - Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)).Magnitude
            local distWorld = (head.Position - myHead.Position).Magnitude
            if onScreen and distFov <= FOVCircle.Radius then
                if distWorld < shortest then
                    shortest = distWorld
                    closest = plr
                end
            end
        end
    end
    return closest
end

-- WallCheck unchanged
local function WallCheck(startPos, endPos)
    local dir = (endPos - startPos).Unit
    local dist = (endPos - startPos).Magnitude
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {LocalPlayer.Character}
    local result = workspace:Raycast(startPos, dir * dist, params)
    if result and result.Instance then
        if not result.Instance:IsDescendantOf(LocalPlayer.Character)
            and not (result.Instance.Name:find("Head") or result.Instance.Name:find("HumanoidRootPart"))
        then
            return true -- ‡πÄ‡∏à‡∏≠‡∏™‡∏¥‡πà‡∏á‡∏Å‡∏µ‡∏î‡∏Ç‡∏ß‡∏≤‡∏á/‡∏Å‡∏≥‡πÅ‡∏û‡∏á
        end
    end
    return false
end

-- Visual effects (laser, bullet) - uses predicted aimPos now
local function FireLaserEffect(fromPos, toPos, color, width, duration)
    local laser = Instance.new("Part")
    laser.Anchored = true
    laser.CanCollide = false
    laser.Material = Enum.Material.Neon
    laser.Color = color or Color3.fromRGB(0,255,0)
    local dist = (toPos-fromPos).Magnitude
    laser.Size = Vector3.new(width or 0.16, width or 0.16, dist)
    laser.CFrame = CFrame.new(fromPos, toPos) * CFrame.new(0, 0, -dist/2)
    laser.Parent = workspace
    Debris:AddItem(laser, duration or 0.22)
end

-- UI: SilentAim, FOV, prediction, antiaim settings, tracer settings
CombatTab:Toggle({
    Title = "Enable Silent Aim (Auto Detect)",
    Default = false,
    Callback = function(v)
        SilentAimEnabled = v
        TracerLine.Visible = v and TracerLine.Visible and showTracer
    end
})

CombatTab:Toggle({
    Title = "Show FOV Circle",
    Default = false,
    Callback = function(v)
        showFov = v
        FOVCircle.Visible = v
    end
})

CombatTab:Slider({
    Title = "FOV Radius",
    Step = 1,
    Value = {Min = 50, Max = 500, Default = FOVCircle.Radius},
    Callback = function(v)
        FOVCircle.Radius = tonumber(v)
    end
})

CombatTab:Slider({
    Title = "Base Prediction (ms fraction)",
    Step = 0.01,
    Value = {Min = 0.00, Max = 0.5, Default = AimSystem.basePrediction},
    Callback = function(v)
        AimSystem.basePrediction = tonumber(v)
        BASE_PREDICTION = AimSystem.basePrediction
    end
})

CombatTab:Slider({
    Title = "Antiaim Threshold",
    Step = 0.1,
    Value = {Min = 0.5, Max = 10, Default = AimSystem.antiaimThreshold},
    Callback = function(v)
        AimSystem.antiaimThreshold = tonumber(v)
    end
})

CombatTab:Slider({
    Title = "Velocity Memory Size",
    Step = 1,
    Value = {Min = 3, Max = 20, Default = AimSystem.bufSize},
    Callback = function(v)
        AimSystem.bufSize = tonumber(v)
    end
})

CombatTab:Toggle({
    Title = "Show Tracer",
    Default = true,
    Callback = function(v)
        showTracer = v
        TracerLine.Visible = SilentAimEnabled and v
    end
})

CombatTab:ColorPicker({
    Title = "Tracer Color",
    Default = tracerColor,
    Callback = function(col)
        tracerColor = col
    end
})

-- Hook send.FireServer to modify bullet aim using AimSystem results
local send = ReplicatedStorage:WaitForChild("Remotes"):WaitForChild("Send")
local oldFire
oldFire = hookfunction(send.FireServer,function(self,...)
    local args = {...}
    if SilentAimEnabled then
        local target = AimSystem:GetBestTargetInFOV()
        if target and target.Character then
            local myHead = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head")
            if not myHead then return oldFire(self,unpack(args)) end

            -- Determine whether target is anti-aiming
            local useHRP = false
            if AimSystem:IsAntiAiming(target) then
                useHRP = true
            end

            local aimPos, part = nil, nil
            if useHRP and target.Character:FindFirstChild("HumanoidRootPart") then
                aimPos, part = AimSystem:GetPredictedPositionForHRP(target, AimSystem.basePrediction)
            elseif target.Character:FindFirstChild("Head") then
                aimPos, part = AimSystem:GetPredictedPositionForHead(target, AimSystem.basePrediction)
            end

            if aimPos and part then
                local wall = WallCheck(myHead.Position, aimPos)
                if wall then
                    args[4] = CFrame.new(math.huge,math.huge,math.huge)
                    args[5] = {[1] = {[1] = {["Instance"]=part,["Position"]=aimPos}}}
                else
                    args[4] = CFrame.new(aimPos)
                    args[5] = {[1] = {[1] = {["Instance"]=part,["Position"]=aimPos}}}
                end
                -- Visual effects
                if showTracer then
                    FireLaserEffect(myHead.Position, aimPos, tracerColor, 0.17, 0.18)
                    local dist = (aimPos-myHead.Position).Magnitude
                    local bullet = Instance.new("Part")
                    bullet.Anchored = true
                    bullet.CanCollide = false
                    bullet.Material = Enum.Material.Neon
                    bullet.Size = Vector3.new(0.1,0.1,dist)
                    bullet.CFrame = CFrame.new(myHead.Position,aimPos)*CFrame.new(0,0,-dist/2)
                    bullet.Color = tracerColor
                    bullet.Parent = workspace
                    Debris:AddItem(bullet,2.7)
                end
            end
        end
    end
    return oldFire(self,unpack(args))
end)

-- Update Tracer + FOV circle each frame and maintain AimSystem velocity updates for all players
RunService.RenderStepped:Connect(function()
    FOVCircle.Position = Vector2.new(Camera.ViewportSize.X/2,Camera.ViewportSize.Y/2)

    -- Update velocities for players we track (keeps antiaim detection running)
    for _,plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("Head") then
            AimSystem:UpdatePlayerVelocity(plr)
        end
    end

    local myHead = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Head")
    local target = AimSystem:GetBestTargetInFOV()
    local part = nil
    if target then
        if AimSystem:IsAntiAiming(target) then
            part = target.Character and target.Character:FindFirstChild("HumanoidRootPart")
        else
            part = target.Character and target.Character:FindFirstChild("Head")
        end
    end
    if SilentAimEnabled and myHead and part then
        local my2D = Vector2.new(Camera:WorldToViewportPoint(myHead.Position).X,Camera:WorldToViewportPoint(myHead.Position).Y)
        local t2D = Vector2.new(Camera:WorldToViewportPoint(part.Position).X, Camera:WorldToViewportPoint(part.Position).Y)
        local distFromCenter = (t2D - Vector2.new(Camera.ViewportSize.X/2,Camera.ViewportSize.Y/2)).Magnitude
        if not showFov or distFromCenter<=FOVCircle.Radius then
            TracerLine.From = my2D
            TracerLine.To = t2D
            TracerLine.Color = tracerColor
            TracerLine.Visible = showTracer
        else
            TracerLine.Visible = false
        end
    else
        TracerLine.Visible = false
    end
end)

-------------------------------------------------
-- ESP ‡∏Ç‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°
-------------------------------------------------
local boxESPEnabled = false
local nameESPEnabled = false
local espPlayers = {}

ESPTab:Toggle({
    Title = "Box ESP",
    Default = false,
    Callback = function(state)
        boxESPEnabled = state
    end
})

ESPTab:Toggle({
    Title = "Name ESP",
    Default = false,
    Callback = function(state)
        nameESPEnabled = state
    end
})

local function createESP(player)
    local lines = {
        top = Drawing.new("Line"),
        bottom = Drawing.new("Line"),
        left = Drawing.new("Line"),
        right = Drawing.new("Line"),
    }
    local nameText = Drawing.new("Text")
    nameText.Size = 16
    nameText.Center = true
    nameText.Outline = true
    nameText.Color = Color3.fromRGB(255, 0, 0)
    nameText.Visible = false
    for _, line in pairs(lines) do
        line.Color = Color3.new(1, 1, 1)
        line.Thickness = 1
        line.Visible = false
    end
    local drawings = {lines.top, lines.bottom, lines.left, lines.right, nameText}
    local conn = RunService.RenderStepped:Connect(function()
        if not player.Character or not player.Character:FindFirstChild("Head") or not player.Character:FindFirstChild("HumanoidRootPart") then
            for _, line in pairs(lines) do line.Visible = false end
            nameText.Visible = false
            return
        end
        local head = player.Character.Head
        local hrp = player.Character.HumanoidRootPart
        local topWorld = head.Position + Vector3.new(0, 1, 0)
        local bottomWorld = hrp.Position - Vector3.new(0, 3.5, 0)
        local top, onTop = Camera:WorldToViewportPoint(topWorld)
        local bottom, onBottom = Camera:WorldToViewportPoint(bottomWorld)
        if onTop and onBottom and top.Z > 0 and bottom.Z > 0 then
            local height = math.abs(top.Y - bottom.Y) * 1.2
            local width = height / 1.5
            local x = top.X - width / 2
            local y = top.Y - height * 0.1
            local tl = Vector2.new(x, y)
            local tr = Vector2.new(x + width, y)
            local bl = Vector2.new(x, y + height)
            local br = Vector2.new(x + width, y + height)
            if boxESPEnabled then
                lines.top.From = tl
                lines.top.To = tr
                lines.bottom.From = bl
                lines.bottom.To = br
                lines.left.From = tl
                lines.left.To = bl
                lines.right.From = tr
                lines.right.To = br
                for _, line in pairs(lines) do line.Visible = true end
            else
                for _, line in pairs(lines) do line.Visible = false end
            end
            if nameESPEnabled then
                nameText.Text = player.Name
                nameText.Position = Vector2.new(top.X, y - 16)
                nameText.Visible = true
            else
                nameText.Visible = false
            end
        else
            for _, line in pairs(lines) do line.Visible = false end
            nameText.Visible = false
        end
    end)
    espPlayers[player] = {conn = conn, drawings = drawings}
end

local function loadESP()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            createESP(player)
        end
    end
    Players.PlayerAdded:Connect(function(player)
        if player ~= LocalPlayer then
            player.CharacterAdded:Connect(function()
                wait(0.1)
                createESP(player)
            end)
        end
    end)
    Players.PlayerRemoving:Connect(function(player)
        if espPlayers[player] then
            espPlayers[player].conn:Disconnect()
            for _, drawing in pairs(espPlayers[player].drawings) do
                drawing:Remove()
            end
            espPlayers[player] = nil
        end
    end)
end

loadESP()
