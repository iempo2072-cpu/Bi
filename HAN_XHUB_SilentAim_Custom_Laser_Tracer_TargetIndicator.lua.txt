local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Debris = game:GetService("Debris")
local TweenService = game:GetService("TweenService")

local lp = Players.LocalPlayer

-- persistent globals (safe across script reloads)
_G._downedProtect = _G._downedProtect or {}
local state = _G._downedProtect

state.separatedParts = state.separatedParts or {}       -- map origPart -> {orig, clone, baseSize}
state.isSeparated = state.isSeparated or false
state.separateConn = state.separateConn or nil
state.antiKillConns = state.antiKillConns or {}         -- map humanoid -> conns

-- Master config controlled by a single GUI toggle
local Config = {
    Enabled = false,           -- master switch (single GUI toggle)
    -- visual/separate settings
    StretchAmount = 2.8,
    SpreadRadius = 18,
    Pulsate = true,
    PulsateMagnitude = 0.28,
    PulsateSpeed = 2.4,
    -- anti-kill settings
    AntiKillEnabled = true,
    ProtectHealth = 2,
    AutoRevive = true,
    MaxHealthOverride = 10000,
    ReviveDelay = 0.08,
}

-- Utilities
local function safeCall(fn, ...)
    local ok, res = pcall(fn, ...)
    return ok, res
end

local function isBasePart(obj)
    return obj and obj:IsA and obj:IsA("BasePart")
end

-- Create clone for a base part using Config values
local function createCloneForPart(part)
    local stretch = Config.StretchAmount
    local spread = Config.SpreadRadius

    local clone = part:Clone()
    clone.Name = part.Name .. "_downed_clone"
    clone.Parent = workspace
    clone.CanCollide = false
    clone.Anchored = false
    clone.Transparency = 0
    clone.Size = Vector3.new(
        math.max(0.05, part.Size.X * (1 + (stretch - 1) * 0.28)),
        math.max(0.05, part.Size.Y * stretch),
        math.max(0.05, part.Size.Z * (1 + (stretch - 1) * 0.28))
    )

    -- random offset direction & initial placement
    local rx = (math.random() - 0.5)
    local ry = (math.random() * 0.8) - 0.4
    local rz = (math.random() - 0.5)
    local dir = Vector3.new(rx, ry, rz)
    if dir.Magnitude == 0 then dir = Vector3.new(0.1, 0, 0) end
    dir = dir.Unit
    local offset = dir * (math.random() * spread)
    clone.CFrame = part.CFrame * CFrame.new(offset)

    -- body velocity for outward push (temporary)
    local bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(1e6, 1e6, 1e6)
    bv.Velocity = dir * (25 * math.clamp(stretch, 1, 6)) + Vector3.new(0, -12, 0)
    bv.P = 3000
    bv.Parent = clone
    Debris:AddItem(bv, 0.9)

    local bg = Instance.new("BodyAngularVelocity")
    bg.MaxTorque = Vector3.new(5e5, 5e5, 5e5)
    bg.AngularVelocity = Vector3.new(math.random(-10,10), math.random(-10,10), math.random(-10,10))
    bg.Parent = clone
    Debris:AddItem(bg, 1.0)

    if clone:IsA("BasePart") then
        clone.Material = Enum.Material.Neon
        clone.CastShadow = false
    end

    return clone
end

-- separateModel: clone parts, hide originals, start pulsate if enabled
local function separateModel(character)
    if state.isSeparated then return end
    if not character then return end

    state.separatedParts = {}
    for _, v in ipairs(character:GetChildren()) do
        if isBasePart(v) then
            -- hide original
            v.Transparency = 1
            v.CanCollide = false
            v.Anchored = false

            local clone = createCloneForPart(v)
            state.separatedParts[v] = { orig = v, clone = clone, baseSize = clone.Size }
        end
    end

    -- Continuous pulsate & orbit if enabled
    if Config.Pulsate then
        if state.separateConn then
            pcall(function() state.separateConn:Disconnect() end)
            state.separateConn = nil
        end
        local startT = tick()
        state.separateConn = RunService.Heartbeat:Connect(function()
            local t = (tick() - startT) * Config.PulsateSpeed
            for _, entry in pairs(state.separatedParts) do
                local clone = entry.clone
                local orig = entry.orig
                if clone and clone.Parent and orig and orig.Parent then
                    local pulse = 1 + math.sin(t) * Config.PulsateMagnitude
                    clone.Size = Vector3.new(entry.baseSize.X, entry.baseSize.Y * pulse, entry.baseSize.Z)
                    local bob = Vector3.new(0, math.sin(t * 1.2) * (Config.PulsateMagnitude * 0.2), 0)
                    local orbit = Vector3.new(math.sin(t * 0.6) * 0.5, 0, math.cos(t * 0.6) * 0.5)
                    local target = orig.CFrame * CFrame.new(orbit + bob)
                    clone.CFrame = clone.CFrame:Lerp(target, 0.18)
                end
            end
        end)
    end

    state.isSeparated = true
end

-- restoreModel: destroy clones, reset originals, stop pulsate
local function restoreModel()
    if state.separateConn then
        pcall(function() state.separateConn:Disconnect() end)
        state.separateConn = nil
    end

    for orig, entry in pairs(state.separatedParts) do
        if entry.clone and entry.clone.Parent then
            entry.clone:Destroy()
        end
        if orig and orig.Parent then
            orig.Transparency = 0
            orig.CanCollide = true
            orig.Anchored = false
        end
    end

    state.separatedParts = {}
    state.isSeparated = false
end

-- Anti-kill: attach handlers to humanoid to clamp health and try revive
local function attachAntiKill(hum)
    if not hum or not hum.Parent then return end
    if state.antiKillConns[hum] then return end

    local conns = {}

    conns.healthConn = hum.HealthChanged:Connect(function(newHealth)
        if not Config.AntiKillEnabled then return end
        if not hum.GetAttribute then return end
        local downed = hum:GetAttribute("HasBeenDowned")
        if downed and newHealth <= Config.ProtectHealth then
            -- temporarily boost MaxHealth then set Health to ProtectHealth
            local ok, prevMax = pcall(function() return hum.MaxHealth end)
            if ok and prevMax then
                pcall(function() hum.MaxHealth = Config.MaxHealthOverride end)
                pcall(function() hum.Health = math.max(Config.ProtectHealth, 1) end)
                task.spawn(function()
                    task.wait(0.12)
                    pcall(function() hum.MaxHealth = prevMax end)
                end)
            else
                pcall(function() hum.Health = math.max(Config.ProtectHealth, 1) end)
            end
        end
    end)

    conns.diedConn = hum.Died:Connect(function()
        if not Config.AntiKillEnabled then return end
        if not hum.GetAttribute then return end
        local wasDowned = hum:GetAttribute("HasBeenDowned")
        if wasDowned and Config.AutoRevive then
            task.wait(Config.ReviveDelay)
            if hum and hum.Parent then
                pcall(function()
                    hum.Health = math.max(Config.ProtectHealth, 1)
                    hum:SetAttribute("IsDead", false)
                    local hrp = hum.Parent:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        hrp.CFrame = hrp.CFrame + Vector3.new(0, 2.5, 0)
                    end
                end)
            end
        end
    end)

    state.antiKillConns[hum] = conns
end

local function detachAntiKill(hum)
    local conns = state.antiKillConns[hum]
    if not conns then return end
    pcall(function()
        if conns.healthConn then conns.healthConn:Disconnect() end
        if conns.diedConn then conns.diedConn:Disconnect() end
    end)
    state.antiKillConns[hum] = nil
end

-- Monitor the local player's humanoid attributes to apply/restore when downed
local function hookLocalHumanoid(hum)
    if not hum then return end

    -- ensure we attach anti-kill when needed immediately
    if hum:GetAttribute and hum:GetAttribute("HasBeenDowned") and Config.Enabled and Config.AntiKillEnabled then
        attachAntiKill(hum)
    end

    -- attribute change watcher
    local attrConn
    attrConn = hum.AttributeChanged:Connect(function(attr)
        if attr == "HasBeenDowned" then
            local downed = hum:GetAttribute("HasBeenDowned")
            if downed and Config.Enabled then
                -- apply both visual and anti-kill
                separateModel(hum.Parent)
                if Config.AntiKillEnabled then attachAntiKill(hum) end
            else
                -- restore both
                restoreModel()
                if Config.AntiKillEnabled then detachAntiKill(hum) end
            end
        elseif attr == "IsDead" then
            -- if marked not dead but separated, keep state (no-op)
        end
    end)

    -- also store attrConn to clean later if humanoid replaced
    state.antiKillConns[hum] = state.antiKillConns[hum] or {}
    state.antiKillConns[hum].attrConn = attrConn
end

-- Monitor character added / current character
local function monitorPlayer()
    if not lp then return end
    local function onCharAdded(char)
        local hum = char:FindFirstChildWhichIsA("Humanoid")
        if hum then
            hookLocalHumanoid(hum)
            -- If currently downed and feature enabled, trigger immediately
            if hum:GetAttribute and hum:GetAttribute("HasBeenDowned") and Config.Enabled then
                separateModel(char)
                if Config.AntiKillEnabled then attachAntiKill(hum) end
            end
        end
    end
    if lp.Character then onCharAdded(lp.Character) end
    lp.CharacterAdded:Connect(onCharAdded)
end

monitorPlayer()

-- GUI: single toggle that controls everything
local function setupGUI(Window)
    if not Window then
        -- try to require WindUI loader commonly used in this project
        local ok, WindUI = pcall(function() return require("./src/Init") end)
        if ok and WindUI then
            Window = WindUI:CreateWindow({Title="Downed Protect", Author="script", Folder="downprotect"})
        end
    end
    if not Window then return end

    local Tab = Window:Tab({Title = "Downed", Icon = "shield"})

    Tab:Toggle({
        Title = "Enable Downed Protection (เนเธขเธ+เธเนเธญเธเธเธฑเธ)",
        Default = Config.Enabled,
        Callback = function(v)
            Config.Enabled = v
            Window:Notify({Title = "Downed Protection", Description = v and "เน€เธเธดเธ”" or "เธเธดเธ”", Duration = 1.6})
            -- If disabling, immediately restore/cleanup if currently separated/attached
            if not v then
                restoreModel()
                for hum, _ in pairs(state.antiKillConns) do
                    -- only detach if it's a humanoid entry (attrConn might exist)
                    if hum and hum:IsA and hum:IsA("Humanoid") then
                        detachAntiKill(hum)
                    end
                end
            else
                -- if enabling and player already downed, apply immediately
                local char = lp.Character
                if char and char:FindFirstChild("Humanoid") then
                    local hum = char:FindFirstChild("Humanoid")
                    if hum and hum:GetAttribute and hum:GetAttribute("HasBeenDowned") then
                        separateModel(char)
                        if Config.AntiKillEnabled then attachAntiKill(hum) end
                    end
                end
            end
        end
    })

    Tab:Slider({
        Title = "Stretch Amount",
        Step = 0.1,
        Value = {Min = 1.0, Max = 8.0, Default = Config.StretchAmount},
        Callback = function(v)
            Config.StretchAmount = tonumber(v)
        end
    })

    Tab:Slider({
        Title = "Spread Radius",
        Step = 1,
        Value = {Min = 0, Max = 60, Default = Config.SpreadRadius},
        Callback = function(v)
            Config.SpreadRadius = tonumber(v)
        end
    })

    Tab:Toggle({
        Title = "Enable AntiKill",
        Default = Config.AntiKillEnabled,
        Callback = function(v)
            Config.AntiKillEnabled = v
            if not v then
                -- detach all anti-kill handlers immediately
                for hum, _ in pairs(state.antiKillConns) do
                    if hum and hum:IsA and hum:IsA("Humanoid") then
                        detachAntiKill(hum)
                    end
                end
            end
        end
    })

    Tab:Slider({
        Title = "Protect Health",
        Step = 1,
        Value = {Min = 1, Max = 50, Default = Config.ProtectHealth},
        Callback = function(v)
            Config.ProtectHealth = tonumber(v)
        end
    })

    Tab:Toggle({
        Title = "Auto Revive",
        Default = Config.AutoRevive,
        Callback = function(v)
            Config.AutoRevive = v
        end
    })

    Tab:Button({
        Title = "Restore Now",
        Callback = function()
            restoreModel()
            -- detach humanoid anti-kill handlers
            for hum, _ in pairs(state.antiKillConns) do
                if hum and hum:IsA and hum:IsA("Humanoid") then
                    detachAntiKill(hum)
                end
            end
            Window:Notify({Title = "Restore", Description = "เธเธทเธเธชเธ เธฒเธเนเธกเน€เธ”เธฅเนเธฅเธฐเธ–เธญเธ”เธเธฒเธฃเธเนเธญเธเธเธฑเธเนเธฅเนเธง", Duration = 1.6})
        end
    })
end

-- try to attach GUI to global Window if present
safeCall(function() setupGUI(rawget(_G, "Window") or rawget(script, "Window")) end)

-- Return API in case other scripts want to control programmatically
return {
    Config = Config,
    separateModel = separateModel,
    restoreModel = restoreModel,
    attachAntiKill = attachAntiKill,
    detachAntiKill = detachAntiKill,
}
